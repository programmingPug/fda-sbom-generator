"""
Vulnerability scanning and security analysis functionality.
"""

import json
import re
import requests
from datetime import datetime
from typing import Dict, List, Optional
from pathlib import Path

from .models import Component, Vulnerability, VulnerabilitySeverity, SBOM


class VulnerabilityScanner:
    """Scanner for security vulnerabilities in components."""
    
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'FDA-SBOM-Generator/0.1.0'
        })
    
    def scan_component(self, component: Component) -> List[Vulnerability]:
        """Scan a single component for vulnerabilities."""
        vulnerabilities = []
        
        # Try different vulnerability sources based on package manager
        if component.package_manager == "pip":
            vulnerabilities.extend(self._scan_python_vulnerabilities(component))
        elif component.package_manager == "npm":
            vulnerabilities.extend(self._scan_npm_vulnerabilities(component))
        elif component.package_manager in ["maven", "gradle"]:
            vulnerabilities.extend(self._scan_java_vulnerabilities(component))
        
        return vulnerabilities
    
    def _scan_python_vulnerabilities(self, component: Component) -> List[Vulnerability]:
        """Scan Python component using PyUp.io Safety database."""
        vulnerabilities = []
        
        try:
            # Use the OSV database for Python packages
            url = "https://api.osv.dev/v1/query"
            payload = {
                "package": {
                    "name": component.name,
                    "ecosystem": "PyPI"
                },
                "version": component.version
            }
            
            response = self.session.post(url, json=payload, timeout=30)
            if response.status_code == 200:
                data = response.json()
                for vuln_data in data.get('vulns', []):
                    vulnerability = self._parse_osv_vulnerability(vuln_data)
                    if vulnerability:
                        vulnerabilities.append(vulnerability)
        
        except Exception as e:
            print(f"Warning: Could not scan Python vulnerabilities for {component.name}: {e}")
        
        return vulnerabilities
    
    def _scan_npm_vulnerabilities(self, component: Component) -> List[Vulnerability]:
        """Scan NPM component using OSV database."""
        vulnerabilities = []
        
        try:
            url = "https://api.osv.dev/v1/query"
            payload = {
                "package": {
                    "name": component.name,
                    "ecosystem": "npm"
                },
                "version": component.version
            }
            
            response = self.session.post(url, json=payload, timeout=30)
            if response.status_code == 200:
                data = response.json()
                for vuln_data in data.get('vulns', []):
                    vulnerability = self._parse_osv_vulnerability(vuln_data)
                    if vulnerability:
                        vulnerabilities.append(vulnerability)
        
        except Exception as e:
            print(f"Warning: Could not scan NPM vulnerabilities for {component.name}: {e}")
        
        return vulnerabilities
    
    def _scan_java_vulnerabilities(self, component: Component) -> List[Vulnerability]:
        """Scan Java component using OSV database."""
        vulnerabilities = []
        
        try:
            url = "https://api.osv.dev/v1/query"
            payload = {
                "package": {
                    "name": component.name,
                    "ecosystem": "Maven"
                },
                "version": component.version
            }
            
            response = self.session.post(url, json=payload, timeout=30)
            if response.status_code == 200:
                data = response.json()
                for vuln_data in data.get('vulns', []):
                    vulnerability = self._parse_osv_vulnerability(vuln_data)
                    if vulnerability:
                        vulnerabilities.append(vulnerability)
        
        except Exception as e:
            print(f"Warning: Could not scan Java vulnerabilities for {component.name}: {e}")
        
        return vulnerabilities
    
    def _parse_osv_vulnerability(self, vuln_data: Dict) -> Optional[Vulnerability]:
        """Parse vulnerability data from OSV format."""
        try:
            vuln_id = vuln_data.get('id', '')
            if not vuln_id:
                return None
                
            summary = vuln_data.get('summary', vuln_data.get('details', ''))
            
            # Extract severity information
            severity = VulnerabilitySeverity.MEDIUM  # Default
            score = None
            
            # Look for CVSS score in database_specific first
            database_specific = vuln_data.get('database_specific', {})
            if 'cvss' in database_specific:
                try:
                    score = float(database_specific['cvss'])
                except (ValueError, TypeError):
                    pass
            
            # Look for severity in severity field
            if 'severity' in vuln_data:
                severity_list = vuln_data['severity']
                if isinstance(severity_list, list) and severity_list:
                    severity_info = severity_list[0]
                    if isinstance(severity_info, dict):
                        if 'score' in severity_info and score is None:
                            try:
                                score = float(severity_info['score'])
                            except (ValueError, TypeError):
                                pass
                        if 'type' in severity_info and severity_info['type'] == 'CVSS_V3':
                            if score is not None:
                                if score >= 9.0:
                                    severity = VulnerabilitySeverity.CRITICAL
                                elif score >= 7.0:
                                    severity = VulnerabilitySeverity.HIGH
                                elif score >= 4.0:
                                    severity = VulnerabilitySeverity.MEDIUM
                                elif score >= 0.1:
                                    severity = VulnerabilitySeverity.LOW
                                else:
                                    severity = VulnerabilitySeverity.INFO
            
            # Look for ecosystem-specific severity information
            ecosystem_specific = vuln_data.get('ecosystem_specific', {})
            if 'events' in ecosystem_specific:
                events = ecosystem_specific['events']
                if isinstance(events, list) and events:
                    for event in events:
                        if isinstance(event, dict) and 'severity' in event:
                            severity_text = event['severity'].upper()
                            if severity_text == 'CRITICAL':
                                severity = VulnerabilitySeverity.CRITICAL
                            elif severity_text == 'HIGH':
                                severity = VulnerabilitySeverity.HIGH
                            elif severity_text == 'MEDIUM':
                                severity = VulnerabilitySeverity.MEDIUM
                            elif severity_text == 'LOW':
                                severity = VulnerabilitySeverity.LOW
                            elif severity_text == 'INFO':
                                severity = VulnerabilitySeverity.INFO
                            break  # Use first severity found
            
            # Fallback: look for severity text in various places
            if score is None:
                severity_text = str(vuln_data).lower()
                if 'critical' in severity_text:
                    severity = VulnerabilitySeverity.CRITICAL
                elif 'high' in severity_text:
                    severity = VulnerabilitySeverity.HIGH
                elif 'low' in severity_text:
                    severity = VulnerabilitySeverity.LOW
                elif 'info' in severity_text:
                    severity = VulnerabilitySeverity.INFO
            
            # Parse dates
            published = None
            modified = None
            
            if 'published' in vuln_data:
                try:
                    published = datetime.fromisoformat(vuln_data['published'].replace('Z', '+00:00'))
                except:
                    pass
            
            if 'modified' in vuln_data:
                try:
                    modified = datetime.fromisoformat(vuln_data['modified'].replace('Z', '+00:00'))
                except:
                    pass
            
            # Extract references
            references = []
            for ref in vuln_data.get('references', []):
                if isinstance(ref, dict) and 'url' in ref:
                    references.append(ref['url'])
                elif isinstance(ref, str):
                    references.append(ref)
            
            return Vulnerability(
                id=vuln_id,
                severity=severity,
                score=score,
                description=summary,
                published=published,
                modified=modified,
                references=references
            )
        
        except Exception as e:
            print(f"Warning: Could not parse vulnerability data: {e}")
            # Return a basic vulnerability with default values instead of None
            return Vulnerability(
                id=vuln_data.get('id', ''),
                severity=VulnerabilitySeverity.MEDIUM,
                score=None,
                description="Failed to parse vulnerability details"
            )


class SecurityAnalyzer:
    """Analyze security posture of SBOM."""
    
    def __init__(self):
        self.vulnerability_scanner = VulnerabilityScanner()
    
    def analyze_sbom(self, sbom: SBOM) -> Dict:
        """Analyze the security posture of an SBOM."""
        analysis = {
            'total_components': len(sbom.components),
            'total_vulnerabilities': 0,
            'vulnerability_by_severity': {
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0,
                'info': 0
            },
            'vulnerable_components': [],
            'most_critical_vulns': [],
            'recommendations': []
        }
        
        for component in sbom.components:
            if component.vulnerabilities:
                analysis['vulnerable_components'].append({
                    'name': component.name,
                    'version': component.version,
                    'vulnerability_count': len(component.vulnerabilities)
                })
                
                for vuln in component.vulnerabilities:
                    analysis['total_vulnerabilities'] += 1
                    analysis['vulnerability_by_severity'][vuln.severity.value] += 1
                    
                    # Track critical vulnerabilities
                    if vuln.severity in [VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH]:
                        analysis['most_critical_vulns'].append({
                            'component': component.name,
                            'version': component.version,
                            'vulnerability_id': vuln.id,
                            'severity': vuln.severity.value,
                            'score': vuln.score,
                            'description': vuln.description
                        })
        
        # Generate recommendations
        analysis['recommendations'] = self._generate_recommendations(analysis)
        
        return analysis
    
    def _generate_recommendations(self, analysis: Dict) -> List[str]:
        """Generate security recommendations based on analysis."""
        recommendations = []
        
        if analysis['vulnerability_by_severity']['critical'] > 0:
            recommendations.append(
                f"URGENT: {analysis['vulnerability_by_severity']['critical']} critical vulnerabilities found. "
                "Address these immediately before FDA submission."
            )
        
        if analysis['vulnerability_by_severity']['high'] > 0:
            recommendations.append(
                f"HIGH PRIORITY: {analysis['vulnerability_by_severity']['high']} high-severity vulnerabilities found. "
                "Plan to address these as soon as possible."
            )
        
        if analysis['total_vulnerabilities'] == 0:
            recommendations.append(
                "GOOD: No known vulnerabilities detected in current component versions."
            )
        
        if len(analysis['vulnerable_components']) > 0:
            recommendations.append(
                f"Consider updating {len(analysis['vulnerable_components'])} vulnerable components to latest versions."
            )
        
        # FDA-specific recommendations
        if analysis['vulnerability_by_severity']['critical'] > 0 or analysis['vulnerability_by_severity']['high'] > 5:
            recommendations.append(
                "FDA COMPLIANCE: Current vulnerability level may impact FDA cybersecurity compliance. "
                "Review FDA guidance on acceptable risk levels."
            )
        
        recommendations.append(
            "Establish a process for regular vulnerability monitoring and patching."
        )
        
        recommendations.append(
            "Document risk assessment and mitigation strategies for any remaining vulnerabilities."
        )
        
        return recommendations
    
    def scan_all_components(self, sbom: SBOM, progress_callback=None) -> SBOM:
        """Scan all components in SBOM for vulnerabilities."""
        total_components = len(sbom.components)
        
        for i, component in enumerate(sbom.components):
            if progress_callback:
                progress_callback(i + 1, total_components, component.name)
            
            vulnerabilities = self.vulnerability_scanner.scan_component(component)
            component.vulnerabilities.extend(vulnerabilities)
        
        return sbom
    
    def get_risk_score(self, sbom: SBOM) -> float:
        """Calculate overall risk score for SBOM (0-10 scale)."""
        if not sbom.components:
            return 0.0
        
        total_score = 0.0
        total_components = len(sbom.components)
        
        for component in sbom.components:
            component_score = 0.0
            
            for vuln in component.vulnerabilities:
                if vuln.score:
                    # Use CVSS score if available
                    component_score = max(component_score, vuln.score)
                else:
                    # Use severity-based scoring
                    severity_scores = {
                        VulnerabilitySeverity.CRITICAL: 9.0,
                        VulnerabilitySeverity.HIGH: 7.0,
                        VulnerabilitySeverity.MEDIUM: 5.0,
                        VulnerabilitySeverity.LOW: 3.0,
                        VulnerabilitySeverity.INFO: 1.0
                    }
                    component_score = max(component_score, severity_scores.get(vuln.severity, 0.0))
            
            total_score += component_score
        
        # Return average risk score
        return total_score / total_components
    
    def generate_security_report(self, sbom: SBOM) -> str:
        """Generate a comprehensive security report."""
        analysis = self.analyze_sbom(sbom)
        risk_score = self.get_risk_score(sbom)
        
        report = []
        report.append("# Security Analysis Report")
        report.append("")
        report.append(f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"**SBOM:** {sbom.document_name}")
        report.append(f"**Overall Risk Score:** {risk_score:.1f}/10.0")
        report.append("")
        
        # Summary
        report.append("## Executive Summary")
        report.append("")
        report.append(f"- **Total Components:** {analysis['total_components']}")
        report.append(f"- **Total Vulnerabilities:** {analysis['total_vulnerabilities']}")
        report.append(f"- **Vulnerable Components:** {len(analysis['vulnerable_components'])}")
        report.append("")
        
        # Vulnerability breakdown
        report.append("## Vulnerability Breakdown")
        report.append("")
        for severity, count in analysis['vulnerability_by_severity'].items():
            if count > 0:
                report.append(f"- **{severity.upper()}:** {count}")
        report.append("")
        
        # Critical vulnerabilities
        if analysis['most_critical_vulns']:
            report.append("## Critical Vulnerabilities")
            report.append("")
            for vuln in analysis['most_critical_vulns'][:10]:  # Top 10
                report.append(f"### {vuln['vulnerability_id']}")
                report.append(f"- **Component:** {vuln['component']} v{vuln['version']}")
                report.append(f"- **Severity:** {vuln['severity'].upper()}")
                if vuln['score']:
                    report.append(f"- **CVSS Score:** {vuln['score']}")
                if vuln['description']:
                    report.append(f"- **Description:** {vuln['description']}")
                report.append("")
        
        # Recommendations
        report.append("## Recommendations")
        report.append("")
        for i, rec in enumerate(analysis['recommendations'], 1):
            report.append(f"{i}. {rec}")
        report.append("")
        
        # FDA compliance notes
        report.append("## FDA Compliance Notes")
        report.append("")
        if risk_score < 3.0:
            report.append("✅ Low risk profile suitable for FDA submission.")
        elif risk_score < 6.0:
            report.append("⚠️ Medium risk profile. Review vulnerabilities before FDA submission.")
        else:
            report.append("❌ High risk profile. Address critical vulnerabilities before FDA submission.")
        
        return "\n".join(report)
