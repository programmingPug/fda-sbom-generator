"""
Vulnerability scanning and security analysis functionality.
"""

import json
import re
import requests
from datetime import datetime
from typing import Dict, List, Optional
from pathlib import Path

from .models import Component, Vulnerability, VulnerabilitySeverity, SBOM


class VulnerabilityScanner:
    """Scanner for security vulnerabilities in components."""
    
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'FDA-SBOM-Generator/0.1.0'
        })
    
    def scan_component(self, component: Component) -> List[Vulnerability]:
        """Scan a single component for vulnerabilities."""
        vulnerabilities = []
        
        # Try different vulnerability sources based on package manager
        if component.package_manager == "pip":
            vulnerabilities.extend(self._scan_python_vulnerabilities(component))
        elif component.package_manager == "npm":
            vulnerabilities.extend(self._scan_npm_vulnerabilities(component))
        elif component.package_manager in ["maven", "gradle"]:
            vulnerabilities.extend(self._scan_java_vulnerabilities(component))
        
        return vulnerabilities
    
    def _scan_python_vulnerabilities(self, component: Component) -> List[Vulnerability]:
        """Scan Python component using PyUp.io Safety database."""
        vulnerabilities = []
        
        try:
            # Use the OSV database for Python packages
            url = "https://api.osv.dev/v1/query"
            payload = {
                "package": {
                    "name": component.name,
                    "ecosystem": "PyPI"
                },
                "version": component.version
            }
            
            response = self.session.post(url, json=payload, timeout=30)
            if response.status_code == 200:
                data = response.json()
                for vuln_data in data.get('vulns', []):
                    vulnerability = self._parse_osv_vulnerability(vuln_data)
                    if vulnerability:
                        vulnerabilities.append(vulnerability)
        
        except Exception as e:
            print(f"Warning: Could not scan Python vulnerabilities for {component.name}: {e}")
        
        return vulnerabilities
    
    def _scan_npm_vulnerabilities(self, component: Component) -> List[Vulnerability]:
        """Scan NPM component using OSV database."""
        vulnerabilities = []
        
        try:
            url = "https://api.osv.dev/v1/query"
            payload = {
                "package": {
                    "name": component.name,
                    "ecosystem": "npm"
                },
                "version": component.version
            }
            
            response = self.session.post(url, json=payload, timeout=30)
            if response.status_code == 200:
                data = response.json()
                for vuln_data in data.get('vulns', []):
                    vulnerability = self._parse_osv_vulnerability(vuln_data)
                    if vulnerability:
                        vulnerabilities.append(vulnerability)
        
        except Exception as e:
            print(f"Warning: Could not scan NPM vulnerabilities for {component.name}: {e}")
        
        return vulnerabilities
    
    def _scan_java_vulnerabilities(self, component: Component) -> List[Vulnerability]:
        """Scan Java component using OSV database."""
        vulnerabilities = []
        
        try:
            url = "https://api.osv.dev/v1/query"
            payload = {
                "package": {
                    "name": component.name,
                    "ecosystem": "Maven"
                },
                "version": component.version
            }
            
            response = self.session.post(url, json=payload, timeout=30)
            if response.status_code == 200:
                data = response.json()
                for vuln_data in data.get('vulns', []):
                    vulnerability = self._parse_osv_vulnerability(vuln_data)
                    if vulnerability:
                        vulnerabilities.append(vulnerability)
        
        except Exception as e:
            print(f"Warning: Could not scan Java vulnerabilities for {component.name}: {e}")
        
        return vulnerabilities
    
    def _parse_osv_vulnerability(self, vuln_data: Dict) -> Optional[Vulnerability]:
        """Parse vulnerability data from OSV format."""
        try:
            vuln_id = vuln_data.get('id', '')
            summary = vuln_data.get('summary', '')
            
            # Extract severity information
            severity_info = vuln_data.get('database_specific', {})
            severity = VulnerabilitySeverity.MEDIUM  # Default
            score = None
            
            # Look for CVSS score in various places
            for event in vuln_data.get('ecosystem_specific', {}).get('events', []):
                if 'severity' in event:
                    severity_text = event['severity'].lower()
                    if 'critical' in severity_text:
                        severity = VulnerabilitySeverity.CRITICAL
                    elif 'high' in severity_text:
                        severity = VulnerabilitySeverity.HIGH
                    elif 'low' in severity_text:
                        severity = VulnerabilitySeverity.LOW
                    elif 'info' in severity_text:
                        severity = VulnerabilitySeverity.INFO
            
            # Extract CVSS score if available
            if 'cvss' in str(vuln_data).lower():
                cvss_match = re.search(r'cvss["\s:]*([0-9.]+)', str(vuln_data), re.IGNORECASE)
                if cvss_match:
                    score = float(cvss_match.group(1))
            
            # Parse dates
            published = None
            modified = None
            
            if 'published' in vuln_data:
                try:
                    published = datetime.fromisoformat(vuln_data['published'].replace('Z', '+00:00'))
                except:
                    pass
            
            if 'modified' in vuln_data:
                try:
                    modified = datetime.fromisoformat(vuln_data['modified'].replace('Z', '+00:00'))
                except:
                    pass
            
            # Extract references
            references = []
            for ref in vuln_data.get('references', []):
                if isinstance(ref, dict) and 'url' in ref:
                    references.append(ref['url'])
                elif isinstance(ref, str):
                    references.append(ref)
            
            return Vulnerability(
                id=vuln_id,
                severity=severity,
                score=score,
                description=summary,
                published=published,
                modified=modified,
                references=references
            )
        
        except Exception as e:
            print(f"Warning: Could not parse vulnerability data: {e}")
            return None


class SecurityAnalyzer:
    """Analyze security posture of SBOM."""
    
    def __init__(self):
        self.vulnerability_scanner = VulnerabilityScanner()
    
    def analyze_sbom(self, sbom: SBOM) -> Dict:
        """Analyze the security posture of an SBOM."""
        analysis = {
            'total_components': len(sbom.components),
            'total_vulnerabilities': 0,
            'vulnerability_by_severity': {
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0,
                'info': 0
            },
            'vulnerable_components': [],
            'most_critical_vulns': [],
            'recommendations': []
        }
        
        for component in sbom.components:
            if component.vulnerabilities:
                analysis['vulnerable_components'].append({
                    'name': component.name,
                    'version': component.version,
                    'vulnerability_count': len(component.vulnerabilities)
                })
                
                for vuln in component.vulnerabilities:
                    analysis['total_vulnerabilities'] += 1
                    analysis['vulnerability_by_severity'][vuln.severity.value] += 1
                    
                    # Track critical vulnerabilities
                    if vuln.severity in [VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH]:
                        analysis['most_critical_vulns'].append({
                            'component': component.name,
                            'version': component.version,
                            'vulnerability_id': vuln.id,
                            'severity': vuln.severity.value,
                            'score': vuln.score,
                            'description': vuln.description
                        })
        
        # Generate recommendations
        analysis['recommendations'] = self._generate_recommendations(analysis)
        
        return analysis
    
    def _generate_recommendations(self, analysis: Dict) -> List[str]:
        """Generate security recommendations based on analysis."""
        recommendations = []
        
        if analysis['vulnerability_by_severity']['critical'] > 0:
            recommendations.append(
                f"URGENT: {analysis['vulnerability_by_severity']['critical']} critical vulnerabilities found. "
                "Address these immediately before FDA submission."
            )
        
        if analysis['vulnerability_by_severity']['high'] > 0:
            recommendations.append(
                f"HIGH PRIORITY: {analysis['vulnerability_by_severity']['high']} high-severity vulnerabilities found. "
                "Plan to address these as soon as possible."
            )
        
        if analysis['total_vulnerabilities'] == 0:
            recommendations.append(
                "GOOD: No known vulnerabilities detected in current component versions."
            )
        
        if len(analysis['vulnerable_components']) > 0:
            recommendations.append(
                f"Consider updating {len(analysis['vulnerable_components'])} vulnerable components to latest versions."
            )
        
        # FDA-specific recommendations
        if analysis['vulnerability_by_severity']['critical'] > 0 or analysis['vulnerability_by_severity']['high'] > 5:
            recommendations.append(
                "FDA COMPLIANCE: Current vulnerability level may impact FDA cybersecurity compliance. "
                "Review FDA guidance on acceptable risk levels."
            )
        
        recommendations.append(
            "Establish a process for regular vulnerability monitoring and patching."
        )
        
        recommendations.append(
            "Document risk assessment and mitigation strategies for any remaining vulnerabilities."
        )
        
        return recommendations
    
    def scan_all_components(self, sbom: SBOM, progress_callback=None) -> SBOM:
        """Scan all components in SBOM for vulnerabilities."""
        total_components = len(sbom.components)
        
        for i, component in enumerate(sbom.components):
            if progress_callback:
                progress_callback(i + 1, total_components, component.name)
            
            vulnerabilities = self.vulnerability_scanner.scan_component(component)
            component.vulnerabilities.extend(vulnerabilities)
        
        return sbom
    
    def get_risk_score(self, sbom: SBOM) -> float:
        """Calculate overall risk score for SBOM (0-10 scale)."""
        if not sbom.components:
            return 0.0
        
        total_score = 0.0
        total_components = len(sbom.components)
        
        for component in sbom.components:
            component_score = 0.0
            
            for vuln in component.vulnerabilities:
                if vuln.score:
                    # Use CVSS score if available
                    component_score = max(component_score, vuln.score)
                else:
                    # Use severity-based scoring
                    severity_scores = {
                        VulnerabilitySeverity.CRITICAL: 9.0,
                        VulnerabilitySeverity.HIGH: 7.0,
                        VulnerabilitySeverity.MEDIUM: 5.0,
                        VulnerabilitySeverity.LOW: 3.0,
                        VulnerabilitySeverity.INFO: 1.0
                    }
                    component_score = max(component_score, severity_scores.get(vuln.severity, 0.0))
            
            total_score += component_score
        
        # Return average risk score
        return total_score / total_components
    
    def generate_security_report(self, sbom: SBOM) -> str:
        """Generate a comprehensive security report."""
        analysis = self.analyze_sbom(sbom)
        risk_score = self.get_risk_score(sbom)
        
        report = []
        report.append("# Security Analysis Report")
        report.append("")
        report.append(f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"**SBOM:** {sbom.document_name}")
        report.append(f"**Overall Risk Score:** {risk_score:.1f}/10.0")
        report.append("")
        
        # Summary
        report.append("## Executive Summary")
        report.append("")
        report.append(f"- **Total Components:** {analysis['total_components']}")
        report.append(f"- **Total Vulnerabilities:** {analysis['total_vulnerabilities']}")
        report.append(f"- **Vulnerable Components:** {len(analysis['vulnerable_components'])}")
        report.append("")
        
        # Vulnerability breakdown
        report.append("## Vulnerability Breakdown")
        report.append("")
        for severity, count in analysis['vulnerability_by_severity'].items():
            if count > 0:
                report.append(f"- **{severity.upper()}:** {count}")
        report.append("")
        
        # Critical vulnerabilities
        if analysis['most_critical_vulns']:
            report.append("## Critical Vulnerabilities")
            report.append("")
            for vuln in analysis['most_critical_vulns'][:10]:  # Top 10
                report.append(f"### {vuln['vulnerability_id']}")
                report.append(f"- **Component:** {vuln['component']} v{vuln['version']}")
                report.append(f"- **Severity:** {vuln['severity'].upper()}")
                if vuln['score']:
                    report.append(f"- **CVSS Score:** {vuln['score']}")
                if vuln['description']:
                    report.append(f"- **Description:** {vuln['description']}")
                report.append("")
        
        # Recommendations
        report.append("## Recommendations")
        report.append("")
        for i, rec in enumerate(analysis['recommendations'], 1):
            report.append(f"{i}. {rec}")
        report.append("")
        
        # FDA compliance notes
        report.append("## FDA Compliance Notes")
        report.append("")
        if risk_score < 3.0:
            report.append("✅ Low risk profile suitable for FDA submission.")
        elif risk_score < 6.0:
            report.append("⚠️ Medium risk profile. Review vulnerabilities before FDA submission.")
        else:
            report.append("❌ High risk profile. Address critical vulnerabilities before FDA submission.")
        
        return "\n".join(report)
