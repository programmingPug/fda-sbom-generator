"""
Unit tests for vulnerability scanning and security analysis.
"""

import json
import pytest
from unittest.mock import Mock, patch, MagicMock
from datetime import datetime

from fda_sbom.vulnerability import VulnerabilityScanner, SecurityAnalyzer
from fda_sbom.models import (
    Component, ComponentType, Vulnerability, VulnerabilitySeverity, 
    SBOM, License
)


class TestVulnerabilityScanner:
    """Test VulnerabilityScanner."""
    
    def test_scanner_initialization(self):
        """Test scanner initialization."""
        scanner = VulnerabilityScanner()
        
        assert scanner.session is not None
        assert 'User-Agent' in scanner.session.headers
        assert 'FDA-SBOM-Generator' in scanner.session.headers['User-Agent']
    
    @patch('requests.Session.post')
    def test_scan_python_component_with_vulnerabilities(self, mock_post):
        """Test scanning Python component with vulnerabilities."""
        # Mock OSV API response with vulnerability
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            'vulns': [
                {
                    'id': 'CVE-2023-12345',
                    'summary': 'Test vulnerability',
                    'database_specific': {},
                    'ecosystem_specific': {
                        'events': [{'severity': 'HIGH'}]
                    },
                    'published': '2023-01-15T10:00:00Z',
                    'modified': '2023-01-16T12:00:00Z',
                    'references': [
                        {'url': 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-12345'}
                    ]
                }
            ]
        }
        mock_post.return_value = mock_response
        
        component = Component(
            name="vulnerable-package",
            version="1.0.0",
            type=ComponentType.LIBRARY,
            package_manager="pip"
        )
        
        scanner = VulnerabilityScanner()
        vulnerabilities = scanner.scan_component(component)
        
        assert len(vulnerabilities) == 1
        vuln = vulnerabilities[0]
        assert vuln.id == 'CVE-2023-12345'
        assert vuln.severity == VulnerabilitySeverity.HIGH
        assert vuln.description == 'Test vulnerability'
        assert len(vuln.references) == 1
        
        # Verify API call
        mock_post.assert_called_once()
        call_args = mock_post.call_args
        assert call_args[1]['json']['package']['name'] == 'vulnerable-package'
        assert call_args[1]['json']['package']['ecosystem'] == 'PyPI'
        assert call_args[1]['json']['version'] == '1.0.0'
    
    @patch('requests.Session.post')
    def test_scan_npm_component(self, mock_post):
        """Test scanning NPM component."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {'vulns': []}
        mock_post.return_value = mock_response
        
        component = Component(
            name="safe-package",
            version="2.0.0",
            type=ComponentType.LIBRARY,
            package_manager="npm"
        )
        
        scanner = VulnerabilityScanner()
        vulnerabilities = scanner.scan_component(component)
        
        assert len(vulnerabilities) == 0
        
        # Verify correct ecosystem was used
        call_args = mock_post.call_args
        assert call_args[1]['json']['package']['ecosystem'] == 'npm'
    
    @patch('requests.Session.post')
    def test_scan_java_component(self, mock_post):
        """Test scanning Java component."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {'vulns': []}
        mock_post.return_value = mock_response
        
        component = Component(
            name="safe-java-lib",
            version="3.0.0",
            type=ComponentType.LIBRARY,
            package_manager="maven"
        )
        
        scanner = VulnerabilityScanner()
        vulnerabilities = scanner.scan_component(component)
        
        assert len(vulnerabilities) == 0
        
        # Verify correct ecosystem was used
        call_args = mock_post.call_args
        assert call_args[1]['json']['package']['ecosystem'] == 'Maven'
    
    @patch('requests.Session.post')
    def test_scan_component_api_error(self, mock_post):
        """Test handling of API errors."""
        mock_response = Mock()
        mock_response.status_code = 500
        mock_post.return_value = mock_response
        
        component = Component(
            name="error-package",
            version="1.0.0",
            package_manager="pip"
        )
        
        scanner = VulnerabilityScanner()
        
        # Should handle error gracefully and return empty list
        vulnerabilities = scanner.scan_component(component)
        assert len(vulnerabilities) == 0
    
    @patch('requests.Session.post')
    def test_scan_component_network_timeout(self, mock_post):
        """Test handling of network timeouts."""
        mock_post.side_effect = TimeoutError("Request timed out")
        
        component = Component(
            name="timeout-package",
            version="1.0.0",
            package_manager="pip"
        )
        
        scanner = VulnerabilityScanner()
        
        # Should handle timeout gracefully
        vulnerabilities = scanner.scan_component(component)
        assert len(vulnerabilities) == 0
    
    def test_parse_osv_vulnerability_with_cvss(self):
        """Test parsing OSV vulnerability with CVSS score."""
        scanner = VulnerabilityScanner()
        
        vuln_data = {
            'id': 'CVE-2023-54321',
            'summary': 'Critical security flaw',
            'database_specific': {
                'cvss': '9.8'
            },
            'ecosystem_specific': {
                'events': [{'severity': 'CRITICAL'}]
            },
            'published': '2023-06-01T00:00:00Z',
            'references': [
                {'url': 'https://example.com/advisory'}
            ]
        }
        
        vulnerability = scanner._parse_osv_vulnerability(vuln_data)
        
        assert vulnerability is not None
        assert vulnerability.id == 'CVE-2023-54321'
        assert vulnerability.severity == VulnerabilitySeverity.CRITICAL
        assert vulnerability.score == 9.8
        assert vulnerability.description == 'Critical security flaw'
        assert len(vulnerability.references) == 1
    
    def test_parse_osv_vulnerability_minimal_data(self):
        """Test parsing OSV vulnerability with minimal data."""
        scanner = VulnerabilityScanner()
        
        vuln_data = {
            'id': 'MINIMAL-001'
        }
        
        vulnerability = scanner._parse_osv_vulnerability(vuln_data)
        
        assert vulnerability is not None
        assert vulnerability.id == 'MINIMAL-001'
        assert vulnerability.severity == VulnerabilitySeverity.MEDIUM  # Default
        assert vulnerability.score is None
        assert vulnerability.description == ''
    
    def test_parse_osv_vulnerability_invalid_data(self):
        """Test parsing invalid vulnerability data."""
        scanner = VulnerabilityScanner()
        
        # Should handle malformed data gracefully
        invalid_data = {'invalid': 'structure'}
        vulnerability = scanner._parse_osv_vulnerability(invalid_data)
        
        # Should return None for invalid data
        assert vulnerability is None
    
    def test_scan_unsupported_package_manager(self):
        """Test scanning component with unsupported package manager."""
        component = Component(
            name="unsupported-package",
            version="1.0.0",
            package_manager="unknown-pm"
        )
        
        scanner = VulnerabilityScanner()
        vulnerabilities = scanner.scan_component(component)
        
        # Should return empty list for unsupported package managers
        assert len(vulnerabilities) == 0


class TestSecurityAnalyzer:
    """Test SecurityAnalyzer."""
    
    def test_analyzer_initialization(self):
        """Test analyzer initialization."""
        analyzer = SecurityAnalyzer()
        
        assert analyzer.vulnerability_scanner is not None
        assert isinstance(analyzer.vulnerability_scanner, VulnerabilityScanner)
    
    def test_analyze_sbom_no_vulnerabilities(self, sample_fda_compliant_sbom):
        """Test analyzing SBOM with no vulnerabilities."""
        analyzer = SecurityAnalyzer()
        
        analysis = analyzer.analyze_sbom(sample_fda_compliant_sbom)
        
        assert analysis['total_components'] == len(sample_fda_compliant_sbom.components)
        assert analysis['total_vulnerabilities'] == 0
        assert analysis['vulnerability_by_severity']['critical'] == 0
        assert analysis['vulnerability_by_severity']['high'] == 0
        assert len(analysis['vulnerable_components']) == 0
        assert len(analysis['most_critical_vulns']) == 0
        assert len(analysis['recommendations']) > 0
    
    def test_analyze_sbom_with_vulnerabilities(self):
        """Test analyzing SBOM with vulnerabilities."""
        sbom = SBOM(
            document_id="vuln-test",
            document_name="Vulnerable SBOM",
            document_namespace="https://test.com/vuln"
        )
        
        # Add component with critical vulnerability
        critical_vuln = Vulnerability(
            id="CVE-2023-CRITICAL",
            severity=VulnerabilitySeverity.CRITICAL,
            score=9.5,
            description="Critical security flaw"
        )
        
        component = Component(
            name="vulnerable-lib",
            version="1.0.0",
            type=ComponentType.LIBRARY,
            vulnerabilities=[critical_vuln]
        )
        sbom.add_component(component)
        
        # Add component with high vulnerability
        high_vuln = Vulnerability(
            id="CVE-2023-HIGH",
            severity=VulnerabilitySeverity.HIGH,
            score=7.8
        )
        
        component2 = Component(
            name="another-lib",
            version="2.0.0",
            type=ComponentType.LIBRARY,
            vulnerabilities=[high_vuln]
        )
        sbom.add_component(component2)
        
        analyzer = SecurityAnalyzer()
        analysis = analyzer.analyze_sbom(sbom)
        
        assert analysis['total_components'] == 2
        assert analysis['total_vulnerabilities'] == 2
        assert analysis['vulnerability_by_severity']['critical'] == 1
        assert analysis['vulnerability_by_severity']['high'] == 1
        assert len(analysis['vulnerable_components']) == 2
        assert len(analysis['most_critical_vulns']) == 2
    
    def test_generate_recommendations_no_vulnerabilities(self):
        """Test generating recommendations for clean SBOM."""
        analyzer = SecurityAnalyzer()
        
        analysis = {
            'total_vulnerabilities': 0,
            'vulnerability_by_severity': {
                'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'info': 0
            },
            'vulnerable_components': []
        }
        
        recommendations = analyzer._generate_recommendations(analysis)
        
        assert len(recommendations) > 0
        assert any("No known vulnerabilities detected" in rec for rec in recommendations)
        assert any("regular vulnerability monitoring" in rec for rec in recommendations)
    
    def test_generate_recommendations_critical_vulnerabilities(self):
        """Test generating recommendations for critical vulnerabilities."""
        analyzer = SecurityAnalyzer()
        
        analysis = {
            'total_vulnerabilities': 5,
            'vulnerability_by_severity': {
                'critical': 2, 'high': 3, 'medium': 0, 'low': 0, 'info': 0
            },
            'vulnerable_components': [{'name': 'lib1'}, {'name': 'lib2'}]
        }
        
        recommendations = analyzer._generate_recommendations(analysis)
        
        assert len(recommendations) > 0
        assert any("URGENT" in rec for rec in recommendations)
        assert any("FDA cybersecurity compliance" in rec for rec in recommendations)
    
    @patch.object(VulnerabilityScanner, 'scan_component')
    def test_scan_all_components(self, mock_scan_component, sample_fda_compliant_sbom):
        """Test scanning all components in SBOM."""
        # Mock vulnerability scanning
        mock_vuln = Vulnerability(
            id="TEST-001",
            severity=VulnerabilitySeverity.MEDIUM,
            description="Test vulnerability"
        )
        mock_scan_component.return_value = [mock_vuln]
        
        analyzer = SecurityAnalyzer()
        
        # Track progress calls
        progress_calls = []
        def progress_callback(current, total, component_name):
            progress_calls.append((current, total, component_name))
        
        result_sbom = analyzer.scan_all_components(
            sample_fda_compliant_sbom, 
            progress_callback=progress_callback
        )
        
        # Should call scan_component for each component
        assert mock_scan_component.call_count == len(sample_fda_compliant_sbom.components)
        
        # Should track progress
        assert len(progress_calls) == len(sample_fda_compliant_sbom.components)
        
        # Components should have vulnerabilities added
        for component in result_sbom.components:
            assert len(component.vulnerabilities) == 1
            assert component.vulnerabilities[0].id == "TEST-001"
    
    def test_get_risk_score_no_components(self):
        """Test risk score calculation for empty SBOM."""
        empty_sbom = SBOM(
            document_id="empty",
            document_name="Empty",
            document_namespace="https://test.com/empty"
        )
        
        analyzer = SecurityAnalyzer()
        risk_score = analyzer.get_risk_score(empty_sbom)
        
        assert risk_score == 0.0
    
    def test_get_risk_score_with_vulnerabilities(self):
        """Test risk score calculation with vulnerabilities."""
        sbom = SBOM(
            document_id="risk-test",
            document_name="Risk Test",
            document_namespace="https://test.com/risk"
        )
        
        # Add component with CVSS score
        vuln_with_score = Vulnerability(
            id="CVE-SCORE",
            severity=VulnerabilitySeverity.HIGH,
            score=8.5
        )
        
        component1 = Component(
            name="scored-lib",
            version="1.0.0",
            vulnerabilities=[vuln_with_score]
        )
        
        # Add component with severity only
        vuln_no_score = Vulnerability(
            id="CVE-NO-SCORE",
            severity=VulnerabilitySeverity.CRITICAL
        )
        
        component2 = Component(
            name="critical-lib",
            version="2.0.0",
            vulnerabilities=[vuln_no_score]
        )
        
        sbom.add_component(component1)
        sbom.add_component(component2)
        
        analyzer = SecurityAnalyzer()
        risk_score = analyzer.get_risk_score(sbom)
        
        # Should be average of max scores per component
        # Component 1: 8.5 (CVSS score)
        # Component 2: 9.0 (Critical severity default)
        expected_score = (8.5 + 9.0) / 2
        assert risk_score == expected_score
    
    def test_generate_security_report(self):
        """Test generating comprehensive security report."""
        sbom = SBOM(
            document_id="report-test",
            document_name="Security Report Test",
            document_namespace="https://test.com/report"
        )
        
        # Add vulnerable component
        vuln = Vulnerability(
            id="CVE-2023-REPORT",
            severity=VulnerabilitySeverity.HIGH,
            score=7.5,
            description="Test vulnerability for report"
        )
        
        component = Component(
            name="report-lib",
            version="1.0.0",
            vulnerabilities=[vuln]
        )
        sbom.add_component(component)
        
        analyzer = SecurityAnalyzer()
        report = analyzer.generate_security_report(sbom)
        
        assert isinstance(report, str)
        assert "Security Analysis Report" in report
        assert "Executive Summary" in report
        assert "Vulnerability Breakdown" in report
        assert "Critical Vulnerabilities" in report
        assert "Recommendations" in report
        assert "FDA Compliance Notes" in report
        assert "CVE-2023-REPORT" in report
        assert "report-lib" in report
    
    def test_generate_security_report_low_risk(self, sample_fda_compliant_sbom):
        """Test security report for low-risk SBOM."""
        analyzer = SecurityAnalyzer()
        report = analyzer.generate_security_report(sample_fda_compliant_sbom)
        
        assert "Low risk profile suitable for FDA submission" in report
    
    def test_generate_security_report_high_risk(self):
        """Test security report for high-risk SBOM."""
        sbom = SBOM(
            document_id="high-risk",
            document_name="High Risk SBOM",
            document_namespace="https://test.com/high-risk"
        )
        
        # Add multiple critical vulnerabilities
        for i in range(3):
            vuln = Vulnerability(
                id=f"CVE-2023-CRITICAL-{i}",
                severity=VulnerabilitySeverity.CRITICAL,
                score=9.0 + i * 0.1
            )
            
            component = Component(
                name=f"critical-lib-{i}",
                version="1.0.0",
                vulnerabilities=[vuln]
            )
            sbom.add_component(component)
        
        analyzer = SecurityAnalyzer()
        report = analyzer.generate_security_report(sbom)
        
        assert "High risk profile" in report
        assert "Address critical vulnerabilities before FDA submission" in report


class TestVulnerabilityIntegration:
    """Test integration between vulnerability scanning and SBOM generation."""
    
    @patch.object(VulnerabilityScanner, 'scan_component')
    def test_vulnerability_integration_with_sbom(self, mock_scan, sample_python_project):
        """Test vulnerability scanning integration with SBOM generation."""
        from fda_sbom.generator import SBOMGenerator
        
        # Mock vulnerability found
        test_vuln = Vulnerability(
            id="CVE-2023-INTEGRATION",
            severity=VulnerabilitySeverity.HIGH,
            description="Integration test vulnerability"
        )
        mock_scan.return_value = [test_vuln]
        
        generator = SBOMGenerator()
        sbom = generator.generate_sbom(
            project_path=sample_python_project,
            target_system="Integration Test",
            manufacturer="Test Inc",
            include_vulnerabilities=True
        )
        
        # Should have called vulnerability scanning
        assert mock_scan.called
        
        # Components should have vulnerabilities
        if sbom.components:
            vulnerable_components = [
                c for c in sbom.components if c.vulnerabilities
            ]
            assert len(vulnerable_components) > 0
    
    def test_vulnerability_severity_mapping(self):
        """Test mapping of vulnerability severities."""
        scanner = VulnerabilityScanner()
        
        # Test severity mapping from OSV data
        test_cases = [
            ({'events': [{'severity': 'CRITICAL'}]}, VulnerabilitySeverity.CRITICAL),
            ({'events': [{'severity': 'high'}]}, VulnerabilitySeverity.HIGH),
            ({'events': [{'severity': 'medium'}]}, VulnerabilitySeverity.MEDIUM),
            ({'events': [{'severity': 'low'}]}, VulnerabilitySeverity.LOW),
            ({'events': [{'severity': 'info'}]}, VulnerabilitySeverity.INFO),
            ({}, VulnerabilitySeverity.MEDIUM)  # Default
        ]
        
        for ecosystem_specific, expected_severity in test_cases:
            vuln_data = {
                'id': 'TEST-001',
                'summary': 'Test',
                'ecosystem_specific': ecosystem_specific
            }
            
            vulnerability = scanner._parse_osv_vulnerability(vuln_data)
            assert vulnerability.severity == expected_severity


class TestVulnerabilityPerformance:
    """Test vulnerability scanning performance."""
    
    @patch('requests.Session.post')
    def test_scan_performance_with_timeout(self, mock_post):
        """Test that vulnerability scanning respects timeouts."""
        # Mock slow response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {'vulns': []}
        mock_post.return_value = mock_response
        
        component = Component(
            name="slow-package",
            version="1.0.0",
            package_manager="pip"
        )
        
        scanner = VulnerabilityScanner()
        
        # Should include timeout in request
        vulnerabilities = scanner.scan_component(component)
        
        # Verify timeout was used
        call_kwargs = mock_post.call_args[1]
        assert 'timeout' in call_kwargs
        assert call_kwargs['timeout'] == 30
    
    def test_scan_multiple_components_efficiency(self):
        """Test scanning multiple components efficiently."""
        sbom = SBOM(
            document_id="efficiency-test",
            document_name="Efficiency Test",
            document_namespace="https://test.com/efficiency"
        )
        
        # Add multiple components
        for i in range(10):
            component = Component(
                name=f"test-package-{i}",
                version="1.0.0",
                package_manager="pip"
            )
            sbom.add_component(component)
        
        analyzer = SecurityAnalyzer()
        
        # Track progress
        progress_updates = []
        def progress_callback(current, total, name):
            progress_updates.append((current, total, name))
        
        with patch.object(analyzer.vulnerability_scanner, 'scan_component') as mock_scan:
            mock_scan.return_value = []  # No vulnerabilities
            
            result_sbom = analyzer.scan_all_components(
                sbom, 
                progress_callback=progress_callback
            )
            
            # Should scan each component exactly once
            assert mock_scan.call_count == 10
            
            # Should track progress correctly
            assert len(progress_updates) == 10
            assert progress_updates[0] == (1, 10, "test-package-0")
            assert progress_updates[-1] == (10, 10, "test-package-9")


if __name__ == "__main__":
    pytest.main([__file__])
